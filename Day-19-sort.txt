169. Majority Element

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 

Constraints:

n == nums.length
1 <= n <= 5 * 104
-231 <= nums[i] <= 231 - 1


sol:

mine(worked but O(nlogn))

class Solution {
    public int majorityElement(int[] nums) {
        
        Arrays.sort(nums);
        int len= nums.length;
        return nums[len/2];
    }
}




optimized:

class Solution {
    public int majorityElement(int[] num) {

        int major=num[0], count = 1;
        for(int i=1; i<num.length;i++){
            if(count==0){
                count++;
                major=num[i];
            }else if(major==num[i]){
                count++;
            }else count--;
            
        }
        return major;
    }
}




217. Contains Duplicate
Easy

3874

927

Add to List

Share
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

 

Example 1:

Input: nums = [1,2,3,1]
Output: true
Example 2:

Input: nums = [1,2,3,4]
Output: false
Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109


my sol:

class Solution {
    public boolean containsDuplicate(int[] nums) {
        
        Arrays.sort(nums);
        
        for(int i=0; i<nums.length-1; i++)
        {
            if(nums[i]==nums[i+1])
                return true;
            
        }
        
        return false;
        
    }
}


T= O(nlogn) S = O(1)


alternate

class Solution {
    public boolean containsDuplicate(int[] nums) {

    final Set<Integer> distinct = new HashSet<Integer>();
    for(int num : nums) {
        if(distinct.contains(num)) {
            return true;
        }
        distinct.add(num);
    }
    return false;
}
}


t= O(N)  S= O(n)



219. Contains Duplicate II
Easy

2171

1774

Add to List

Share
Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.

 

Example 1:

Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:

Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
 

Constraints:

1 <= nums.length <= 105
-109 <= nums[i] <= 109
0 <= k <= 105



my sol:

class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        
        if(nums.length == 0 )
            return false;
        
        for(int i=0; i< nums.length; i++)
        {
            for(int j=i+1; j<nums.length; j++)
            {
                if(nums[i]== nums[j] && Math.abs(i-j)<=k)
                    return true;
            }
        }
        
        return false;
        
    }
}


O(N^2), O(1)



best sol:

class Solution {
   public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<Integer>();
        for(int i = 0; i < nums.length; i++){
            if(i > k) set.remove(nums[i-k-1]);
            if(!set.add(nums[i])) return true;
        }
        return false;
 }
}